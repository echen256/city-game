/**
 * TributariesGenerator.js - Generate river tributaries using L-systems
 * 
 * Creates tributary networks after main rivers are generated by:
 * 1. Weighting edges based on distance from rivers (high = river, low = far from river)
 * 2. Using L-system grammar to generate branching patterns
 * 3. Limited to depth 3 for performance and realism
 */

import { GraphUtils } from '../geometry/graph/GraphUtils.js';
import { PathFinder } from './Pathfinder.js';

/**
 * @typedef {Object} TributarySettings
 * @property {number} [maxDepth=3] - Maximum branching depth
 * @property {number} [riverEdgeWeight=100] - Weight for edges that are part of rivers
 * @property {number} [baseEdgeWeight=1] - Base weight for non-river edges
 * @property {number} [maxDistanceInfluence=50] - Maximum distance for weight influence
 * @property {number} [branchProbability=0.7] - Probability of creating a branch at each step
 * @property {number} [minTributaryLength=3] - Minimum length for a tributary
 */

/**
 * @typedef {Object} LSystemRule
 * @property {string} symbol - The symbol this rule applies to
 * @property {string} replacement - What to replace the symbol with
 * @property {number} probability - Probability of applying this rule (0-1)
 */

/**
 * Generates tributary networks using L-systems and weighted pathfinding
 */
export class TributariesGenerator {
  /**
   * @param {Object} voronoiGenerator - Voronoi diagram generator
   * @param {TributarySettings} settings - Generator settings
   */
  constructor(voronoiGenerator, settings = {}) {
    /** @type {Object} */
    this.voronoiGenerator = voronoiGenerator;
    
    /** @type {TributarySettings} */
    this.settings = {
      maxDepth: 3,
      riverEdgeWeight: 100,
      baseEdgeWeight: 1,
      maxDistanceInfluence: 50,
      branchProbability: 0.7,
      minTributaryLength: 3,
      ...settings
    };
    
    /** @type {Array<Array<number>>} */
    this.tributaryPaths = [];
    
    /** @type {Set<number>} */
    this.riverVertices = new Set();
    
    /** @type {Array<Array<number>>} */
    this.mainRiverPaths = [];
    
    /** @type {PathFinder} */
    this.pathfinder = new PathFinder(voronoiGenerator.delaunatorWrapper);
    
    /** @type {Array<LSystemRule>} */
    this.lSystemRules = [
      { symbol: 'F', replacement: 'F[+F]F[-F]F', probability: 0.6 },
      { symbol: 'F', replacement: 'FF[+F]', probability: 0.3 },
      { symbol: 'F', replacement: 'F[-F]F', probability: 0.1 }
    ];
    
    console.log('TributariesGenerator: Initialized with max depth', this.settings.maxDepth);
  }
  
  /**
   * Generate tributaries for existing river network
   * @param {Array<Array<number>>} riverPaths - Main river paths (vertex indices)
   * @param {Object} originalGraph - Original graph before river partitioning
   * @returns {Array<Array<number>>} Generated tributary paths
   */
  generateTributaries(riverPaths, originalGraph) {
    console.log(`TributariesGenerator: Generating tributaries for ${riverPaths.length} main rivers...`);
    console.log('TributariesGenerator: River paths:', riverPaths);
    
    this.mainRiverPaths = riverPaths;
    this.tributaryPaths = [];
    
    // Store all river vertices for weighting
    this.riverVertices.clear();
    riverPaths.forEach((path, index) => {
      console.log(`TributariesGenerator: River ${index} has ${path.length} vertices:`, path);
      path.forEach(vertex => this.riverVertices.add(vertex));
    });
    
    console.log(`TributariesGenerator: Identified ${this.riverVertices.size} river vertices`);
    
    // Create weighted graph based on distance from rivers
    const weightedGraph = this.createWeightedGraph(originalGraph);
    
    // Generate tributaries for each main river
    riverPaths.forEach((riverPath, riverIndex) => {
      console.log(`TributariesGenerator: Processing river ${riverIndex + 1} with ${riverPath.length} vertices...`);
      const tributaries = this.generateTributariesForRiver(riverPath, weightedGraph, riverIndex);
      for (const tributary of tributaries) {
        console.log(tributary);
      }
      console.log(`TributariesGenerator: River ${riverIndex + 1} generated ${tributaries.length} tributaries`);
      this.tributaryPaths.push(...tributaries);
    });
    
    console.log(`TributariesGenerator: Generated ${this.tributaryPaths.length} tributaries total`);
    console.log('TributariesGenerator: All tributary paths:', this.tributaryPaths);
    return this.tributaryPaths;
  }
  
  /**
   * Create a weighted copy of the graph based on distance from rivers
   * @param {Object} originalGraph - Original graph data
   * @returns {Object} Graph with weighted edges
   */
  createWeightedGraph(originalGraph) {
    console.log('TributariesGenerator: Creating weighted graph based on river distances...');
    console.log('TributariesGenerator: Original graph has', originalGraph.circumcenters.length, 'vertices and', originalGraph.voronoiEdges.size, 'edges');
    
    // Create a copy of the graph data (originalGraph is already a graph object, not DelaunatorWrapper)
    const weightedGraph = {
      circumcenters: [...originalGraph.circumcenters],
      voronoiVertexVertexMap: { ...originalGraph.voronoiVertexVertexMap },
      voronoiEdges: new Map(originalGraph.voronoiEdges)
    };
    
    // Calculate distance from each vertex to nearest river vertex
    const riverDistances = this.calculateRiverDistances(weightedGraph);
    console.log(`TributariesGenerator: Calculated distances for ${riverDistances.size} vertices from rivers`);
    
    let riverEdgeCount = 0;
    let normalEdgeCount = 0;
    
    // Update edge weights based on distance from rivers
    for (const [edgeKey, edge] of weightedGraph.voronoiEdges.entries()) {
      const [vertex1, vertex2] = edgeKey.split('-').map(Number);
      
      // If either vertex is part of a river, use high weight
      if (this.riverVertices.has(vertex1) || this.riverVertices.has(vertex2)) {
        edge.weight = this.settings.riverEdgeWeight;
        riverEdgeCount++;
      } else {
        // Weight decreases with distance from rivers
        const dist1 = riverDistances.get(vertex1) || this.settings.maxDistanceInfluence;
        const dist2 = riverDistances.get(vertex2) || this.settings.maxDistanceInfluence;
        const avgDistance = (dist1 + dist2) / 2;
        
        // Exponential decay: closer to rivers = lower weight (easier pathfinding)
        const distanceWeight = Math.exp(avgDistance / this.settings.maxDistanceInfluence);
        edge.weight = this.settings.baseEdgeWeight * distanceWeight;
        normalEdgeCount++;
      }
    }
    
    console.log(`TributariesGenerator: Set weights for ${riverEdgeCount} river edges and ${normalEdgeCount} normal edges`);
    console.log('TributariesGenerator: Weighted graph creation complete');
    return weightedGraph;
  }
  
  /**
   * Calculate distances from each vertex to the nearest river vertex
   * @param {Object} graph - Graph data
   * @returns {Map<number, number>} Map of vertex index to distance from nearest river
   */
  calculateRiverDistances(graph) {
    const distances = new Map();
    const visited = new Set();
    const queue = [];
    
    // Initialize queue with all river vertices at distance 0
    for (const riverVertex of this.riverVertices) {
      if (graph.circumcenters[riverVertex]) {
        distances.set(riverVertex, 0);
        queue.push({ vertex: riverVertex, distance: 0 });
        visited.add(riverVertex);
      }
    }
    
    // BFS to calculate distances
    while (queue.length > 0) {
      const { vertex, distance } = queue.shift();
      
      const connections = graph.voronoiVertexVertexMap[vertex] || [];
      for (const neighbor of connections) {
        if (!visited.has(neighbor) && graph.circumcenters[neighbor]) {
          const newDistance = distance + 1;
          if (newDistance <= this.settings.maxDistanceInfluence) {
            distances.set(neighbor, newDistance);
            queue.push({ vertex: neighbor, distance: newDistance });
            visited.add(neighbor);
          }
        }
      }
    }
    
    console.log(`TributariesGenerator: Calculated distances for ${distances.size} vertices`);
    return distances;
  }
  
  /**
   * Generate tributaries for a single main river
   * @param {Array<number>} riverPath - Main river path
   * @param {Object} weightedGraph - Graph with weighted edges
   * @param {number} riverIndex - Index of the river
   * @returns {Array<Array<number>>} Generated tributary paths
   */
  generateTributariesForRiver(riverPath, weightedGraph, riverIndex) {
    const tributaries = [];
    
    // Generate L-system string for branching pattern
    const lSystemString = this.generateLSystemString('F', this.settings.maxDepth);
    console.log(`TributariesGenerator: L-system pattern for river ${riverIndex}: ${lSystemString}`);
    
    // Find potential branching points along the river
    const branchingPoints = this.findBranchingPoints(riverPath, weightedGraph);
    console.log('--------------------------------');
    console.log(branchingPoints);
    console.log(`TributariesGenerator: Found ${branchingPoints.length} potential branching points`);
    console.log('TributariesGenerator: Branching points:', branchingPoints);
    
    // Execute L-system commands to create tributaries
    const tributaryCommands = this.parseLSystemString(lSystemString);
    console.log(`TributariesGenerator: Generated ${tributaryCommands.length} tributary commands:`, tributaryCommands);
    
    let commandIndex = 0;
    for (const branchPoint of branchingPoints) {
      if (commandIndex >= tributaryCommands.length) {
        console.log(`TributariesGenerator: No more commands (${commandIndex}/${tributaryCommands.length}), stopping`);
        break;
      }
      
      const command = tributaryCommands[commandIndex];
      console.log(`TributariesGenerator: Processing command ${commandIndex}:`, command, 'at branch point:', branchPoint);
      
      if (command.type === 'branch') {
        const tributary = this.createTributary(
          branchPoint.vertex, 
          branchPoint.direction,
          weightedGraph, 
          command.depth,
          riverIndex
        );
        
        console.log(`TributariesGenerator: Tributary creation result:`, tributary);
        
        if (tributary && tributary.length >= this.settings.minTributaryLength) {
          tributaries.push(tributary);
          console.log(`TributariesGenerator: Accepted tributary with ${tributary.length} vertices (depth ${command.depth})`);
        } else if (tributary) {
          console.log(`TributariesGenerator: Rejected tributary (length ${tributary.length} < min ${this.settings.minTributaryLength})`);
        } else {
          console.log(`TributariesGenerator: Failed to create tributary`);
        }
      }
      commandIndex++;
    }
    
    return tributaries;
  }
  
  /**
   * Generate L-system string using grammar rules
   * @param {string} axiom - Starting symbol
   * @param {number} iterations - Number of iterations
   * @returns {string} Generated L-system string
   */
  generateLSystemString(axiom, iterations) {
    let current = axiom;
    
    for (let i = 0; i < iterations; i++) {
      let next = '';
      
      for (const symbol of current) {
        const applicableRules = this.lSystemRules.filter(rule => rule.symbol === symbol);
        
        if (applicableRules.length > 0) {
          // Choose rule based on probability
          const rand = Math.random();
          let cumulativeProbability = 0;
          let selectedRule = null;
          
          for (const rule of applicableRules) {
            cumulativeProbability += rule.probability;
            if (rand <= cumulativeProbability) {
              selectedRule = rule;
              break;
            }
          }
          
          next += selectedRule ? selectedRule.replacement : symbol;
        } else {
          next += symbol;
        }
      }
      
      current = next;
    }
    
    return current;
  }
  
  /**
   * Parse L-system string into executable commands
   * @param {string} lSystemString - L-system string to parse
   * @returns {Array<Object>} Array of command objects
   */
  parseLSystemString(lSystemString) {
    const commands = [];
    let depth = 0;
    
    for (const symbol of lSystemString) {
      switch (symbol) {
        case 'F':
          // Forward/extend command - not used for branching
          break;
        case '+':
          commands.push({ type: 'branch', direction: 'left', depth });
          break;
        case '-':
          commands.push({ type: 'branch', direction: 'right', depth });
          break;
        case '[':
          depth++;
          break;
        case ']':
          depth = Math.max(0, depth - 1);
          break;
      }
    }
    
    return commands;
  }
  
  /**
   * Find potential branching points along a river
   * @param {Array<number>} riverPath - River path vertices
   * @param {Object} graph - Graph data
   * @returns {Array<Object>} Branching point objects
   */
  findBranchingPoints(riverPath, graph) {
    const branchingPoints = [];
    
    // Skip first and last few vertices to avoid endpoints
    const startSkip = Math.min(2, Math.floor(riverPath.length * 0.1));
    const endSkip = Math.min(2, Math.floor(riverPath.length * 0.1));
    
    for (let i = startSkip; i < riverPath.length - endSkip; i++) {
      const vertex = riverPath[i];
      console.log(vertex);
      const connections = graph.voronoiVertexVertexMap[vertex] || [];
      
      // Potential branching point if vertex has connections to non-river vertices
      const nonRiverConnections = connections.filter(conn => !this.riverVertices.has(conn));
      
      if (nonRiverConnections.length > 0) {
        // Determine branching direction based on river flow
        const direction = this.determineFlowDirection(riverPath, i);
        
        branchingPoints.push({
          vertex,
          connections: nonRiverConnections,
          direction,
          riverIndex: i
        });
      }
    }
    
    return branchingPoints;
  }
  
  /**
   * Determine flow direction at a point in the river
   * @param {Array<number>} riverPath - River path vertices
   * @param {number} index - Index in the river path
   * @returns {string} Flow direction ('left' or 'right')
   */
  determineFlowDirection(riverPath, index) {
    // Simple determination based on position in river
    // Could be enhanced with actual geometric calculations
    return (index % 2 === 0) ? 'left' : 'right';
  }
  
  /**
   * Create a single tributary branch
   * @param {number} startVertex - Starting vertex for tributary
   * @param {string} direction - Branching direction
   * @param {Object} weightedGraph - Graph with weighted edges
   * @param {number} depth - Current branching depth
   * @param {number} riverIndex - Parent river index
   * @returns {Array<number>|null} Tributary path or null if failed
   */
  createTributary(startVertex, direction, weightedGraph, depth, riverIndex) {
    // Find a suitable endpoint for the tributary
    const endVertex = this.findTributaryEndpoint(startVertex, direction, weightedGraph, depth);
    console.log('--------------------------------');
    console.log(endVertex);
    if (!endVertex) {
      return null;
    }
    
    // Use pathfinding to create the tributary
    const tributaryPath = this.pathfinder.findPath(
      startVertex,
      endVertex,
      weightedGraph.voronoiVertexVertexMap,
      weightedGraph.voronoiEdges,
      weightedGraph.circumcenters
    );
    
    if (tributaryPath.length < this.settings.minTributaryLength) {
      return null;
    }
    
    console.log(`TributariesGenerator: Created tributary from ${startVertex} to ${endVertex} (${tributaryPath.length} vertices, depth ${depth})`);
    return tributaryPath;
  }
  
  /**
   * Find a suitable endpoint for a tributary
   * @param {number} startVertex - Starting vertex
   * @param {string} direction - Branching direction
   * @param {Object} graph - Graph data
   * @param {number} depth - Current depth
   * @returns {number|null} Endpoint vertex or null
   */
  findTributaryEndpoint(startVertex, direction, graph, depth) {
    const startPos = graph.circumcenters[startVertex];
    if (!startPos) return null;
    
    // Search for endpoints within a reasonable distance
    const maxDistance = 30 / (depth + 1); // Shorter tributaries at higher depths
    const candidates = [];
    
    for (let i = 0; i < graph.circumcenters.length; i++) {
      const vertex = graph.circumcenters[i];
      if (!vertex || this.riverVertices.has(i) || i === startVertex) continue;
      
      const distance = Math.sqrt(
        Math.pow(vertex.x - startPos.x, 2) + 
        Math.pow(vertex.z - startPos.z, 2)
      );
      candidates.push({ vertex: i, distance });
      // if (distance <= maxDistance && distance >= 5) {
      //   // Check if direction matches
      //   const isLeftSide = vertex.x < startPos.x;
      //   const directionMatches = (direction === 'left' && isLeftSide) || 
      //                           (direction === 'right' && !isLeftSide);
        
      //  // if (directionMatches) {
      //     candidates.push({ vertex: i, distance });
      //  // }
      // }
    }
    console.log('--------------------------------');
    console.log(candidates);
    if (candidates.length === 0) return null;
    
    // Choose a random candidate, favoring closer ones
    candidates.sort((a, b) => a.distance - b.distance);

    console.log(candidates);
    const maxCandidates = Math.min(candidates.length, 5);
    const selectedIndex = Math.floor(Math.random() * maxCandidates);
    
    return candidates[selectedIndex].vertex;
  }
  
  /**
   * Get all generated tributary paths
   * @returns {Array<Array<number>>} Array of tributary paths
   */
  getTributaryPaths() {
    return [...this.tributaryPaths];
  }
  
  /**
   * Clear all tributary data
   */
  clearTributaries() {
    this.tributaryPaths = [];
    this.riverVertices.clear();
    this.mainRiverPaths = [];
  }
  
  /**
   * Get statistics about generated tributaries
   * @returns {Object} Tributary statistics
   */
  getTributaryStats() {
    const totalTributaries = this.tributaryPaths.length;
    const totalVertices = this.tributaryPaths.reduce((sum, path) => sum + path.length, 0);
    const averageLength = totalTributaries > 0 ? totalVertices / totalTributaries : 0;
    const longestTributary = totalTributaries > 0 ? 
      Math.max(...this.tributaryPaths.map(path => path.length)) : 0;
    
    return {
      totalTributaries,
      totalVertices,
      averageLength,
      longestTributary,
      mainRivers: this.mainRiverPaths.length
    };
  }
}