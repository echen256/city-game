/**
 * TributariesGenerator.js - Generate river tributaries using L-systems
 * 
 * Creates tributary networks after main rivers are generated by:
 * 1. Weighting edges based on distance from rivers (high = river, low = far from river)
 * 2. Using L-system grammar to generate branching patterns
 * 3. Limited to depth 3 for performance and realism
 */

import { GraphUtils } from '../geometry/graph/GraphUtils.js';
import { PathFinder } from './Pathfinder.js';

/**
 * @typedef {Object} TributarySettings
 * @property {number} [maxDepth=3] - Maximum branching depth
 * @property {number} [riverEdgeWeight=100] - Weight for edges that are part of rivers
 * @property {number} [baseEdgeWeight=1] - Base weight for non-river edges
 * @property {number} [maxDistanceInfluence=50] - Maximum distance for weight influence
 * @property {number} [branchProbability=0.7] - Probability of creating a branch at each step
 * @property {number} [minTributaryLength=10] - Minimum length for a tributary
 */

/**
 * @typedef {Object} LSystemRule
 * @property {string} symbol - The symbol this rule applies to
 * @property {string} replacement - What to replace the symbol with
 * @property {number} probability - Probability of applying this rule (0-1)
 */

/**
 * Generates tributary networks using L-systems and weighted pathfinding
 */
export class TributariesGenerator {
  /**
   * @param {Object} voronoiGenerator - Voronoi diagram generator
   * @param {TributarySettings} settings - Generator settings
   */
  constructor(voronoiGenerator, settings = {}) {
    /** @type {Object} */
    this.voronoiGenerator = voronoiGenerator;
    
    /** @type {TributarySettings} */
    this.settings = {
      maxDepth: 3,
      riverEdgeWeight: 100,
      baseEdgeWeight: 1,
      maxDistanceInfluence: 50,
      branchProbability: 0.7,
      minTributaryLength: 10,
      minTributaryDistance: 15,
      maxTributaryDistance: 150,
      branchingSeparation: 5,
      ...settings
    };
    
    /** @type {number|undefined} */
    this._seed = undefined;
    
    /** @type {Array<Array<number>>} */
    this.tributaryPaths = [];
    
    /** @type {Set<number>} */
    this.riverVertices = new Set();
    
    /** @type {Array<Array<number>>} */
    this.mainRiverPaths = [];
    
    /** @type {PathFinder} */
    this.pathfinder = new PathFinder(voronoiGenerator.delaunatorWrapper);
    
    /** @type {Array<LSystemRule>} */
    this.lSystemRules = [
      { symbol: 'F', replacement: 'F[+F]F', probability: 0.4 },    // Reduced branching
      { symbol: 'F', replacement: 'FF[+F]', probability: 0.3 },
      { symbol: 'F', replacement: 'F[-F]F', probability: 0.2 },
      { symbol: 'F', replacement: 'FF', probability: 0.1 }         // No branching option
    ];
    
    // Initialize seed if provided
    if (this.settings.seed !== undefined) {
      this.seedRandom(this.settings.seed);
    }
    
    console.log('TributariesGenerator: Initialized with max depth', this.settings.maxDepth);
  }
  
  /**
   * Set a seed for deterministic random number generation
   * @param {number} seed - The seed value
   */
  seedRandom(seed) {
    this._seed = seed;
  }
  
  /**
   * Set the seeded random number generator
   * @param {Function} seededRandom - Seeded random function from seedrandom library
   */
  setSeededRandom(seededRandom) {
    this._seededRandom = seededRandom;
  }

  /**
   * Generate a seeded random number between 0 and 1
   * Uses the same algorithm as VoronoiGenerator for consistency
   * @returns {number} Random number between 0 and 1
   */
  random() {
    if (this._seededRandom) {
      return this._seededRandom();
    }
    if (this._seed === undefined) {
      return Math.random();
    }
    this._seed = (this._seed * 16807) % 2147483647;
    return (this._seed - 1) / 2147483646;
  }
  
  /**
   * Generate tributaries for existing river network
   * @param {Array<Array<number>>} riverPaths - Main river paths (vertex indices)
   * @param {Object} originalGraph - Original graph before river partitioning
   * @returns {Array<Array<number>>} Generated tributary paths
   */
  generateTributaries(riverPaths, originalGraph) {
    console.log(`TributariesGenerator: Generating tributaries for ${riverPaths.length} main rivers...`);
    console.log('TributariesGenerator: River paths:', riverPaths);
    
    this.mainRiverPaths = riverPaths;
    this.tributaryPaths = [];
    
    // Store all river vertices for weighting
    this.riverVertices.clear();
    riverPaths.forEach((path, index) => {
      console.log(`TributariesGenerator: River ${index} has ${path.length} vertices:`, path);
      path.forEach(vertex => this.riverVertices.add(vertex));
    });
    
    console.log(`TributariesGenerator: Identified ${this.riverVertices.size} river vertices`);
    
    // Create weighted graph based on distance from rivers
    const weightedGraph = this.createWeightedGraph(originalGraph);
    
    // Generate tributaries for each main river
    riverPaths.forEach((riverPath, riverIndex) => {
      console.log(`TributariesGenerator: Processing river ${riverIndex + 1} with ${riverPath.length} vertices...`);
      const tributaries = this.generateTributariesForRiver(riverPath, weightedGraph, riverIndex);
      for (const tributary of tributaries) {
        console.log(tributary);
      }
      console.log(`TributariesGenerator: River ${riverIndex + 1} generated ${tributaries.length} tributaries`);
      this.tributaryPaths.push(...tributaries);
    });
    
    console.log(`TributariesGenerator: Generated ${this.tributaryPaths.length} tributaries total`);
    console.log('TributariesGenerator: All tributary paths:', this.tributaryPaths);
    return this.tributaryPaths;
  }
  
  /**
   * Create a weighted copy of the graph based on distance from rivers
   * @param {Object} originalGraph - Original graph data
   * @returns {Object} Graph with weighted edges
   */
  createWeightedGraph(originalGraph) {
    console.log('TributariesGenerator: Creating weighted graph based on river distances...');
    console.log('TributariesGenerator: Original graph has', originalGraph.circumcenters.length, 'vertices and', originalGraph.voronoiEdges.size, 'edges');
    
    // Create a copy of the graph data (originalGraph is already a graph object, not DelaunatorWrapper)
    const weightedGraph = {
      circumcenters: [...originalGraph.circumcenters],
      voronoiVertexVertexMap: { ...originalGraph.voronoiVertexVertexMap },
      voronoiEdges: new Map(originalGraph.voronoiEdges)
    };
    
    // Calculate distance from each vertex to nearest river vertex
    const riverDistances = this.calculateRiverDistances(weightedGraph);
    console.log(`TributariesGenerator: Calculated distances for ${riverDistances.size} vertices from rivers`);
    
    let riverEdgeCount = 0;
    let normalEdgeCount = 0;
    
    let boundaryEdgeCount = 0;
    const boundaryWeight = 1000; // Very high weight to discourage boundary usage
    
    // Update edge weights based on distance from rivers and boundary proximity
    for (const [edgeKey, edge] of weightedGraph.voronoiEdges.entries()) {
      const [vertex1, vertex2] = edgeKey.split('-').map(Number);
      
      // Check if this edge is near grid boundaries
      const isBoundaryEdge = this.isBoundaryEdge(vertex1, vertex2, weightedGraph);
      
      if (isBoundaryEdge) {
        // Apply very high weight to boundary edges to discourage pathfinding
        edge.weight = boundaryWeight;
        boundaryEdgeCount++;
      } else if (this.riverVertices.has(vertex1) || this.riverVertices.has(vertex2)) {
        // If either vertex is part of a river, use high weight
        edge.weight = this.settings.riverEdgeWeight;
        riverEdgeCount++;
      } else {
        // Weight decreases with distance from rivers
        const dist1 = riverDistances.get(vertex1) || this.settings.maxDistanceInfluence;
        const dist2 = riverDistances.get(vertex2) || this.settings.maxDistanceInfluence;
        const avgDistance = (dist1 + dist2) / 2;
        
        // Exponential decay: closer to rivers = lower weight (easier pathfinding)
        const distanceWeight = Math.exp(avgDistance / this.settings.maxDistanceInfluence);
        edge.weight = this.settings.baseEdgeWeight * distanceWeight;
        normalEdgeCount++;
      }
    }
    
    console.log(`TributariesGenerator: Set weights for ${riverEdgeCount} river edges, ${normalEdgeCount} normal edges, and ${boundaryEdgeCount} boundary edges`);
    console.log('TributariesGenerator: Weighted graph creation complete');
    return weightedGraph;
  }
  
  /**
   * Check if an edge connects vertices near the grid boundary
   * @param {number} vertex1 - First vertex index
   * @param {number} vertex2 - Second vertex index  
   * @param {Object} graph - Graph data
   * @returns {boolean} True if edge is near boundary
   */
  isBoundaryEdge(vertex1, vertex2, graph) {
    const pos1 = graph.circumcenters[vertex1];
    const pos2 = graph.circumcenters[vertex2];
    
    if (!pos1 || !pos2) return false;
    
    // Get grid size from voronoi generator settings
    const gridSize = this.voronoiGenerator.settings.gridSize;
    const boundaryTolerance = 30; // Distance from boundary to consider "boundary edge"
    
    // Check if either vertex is near any boundary
    const isNearBoundary = (pos) => {
      return pos.x <= boundaryTolerance ||                    // Near left edge
             pos.x >= (gridSize - boundaryTolerance) ||       // Near right edge
             pos.z <= boundaryTolerance ||                    // Near top edge
             pos.z >= (gridSize - boundaryTolerance);         // Near bottom edge
    };
    
    return isNearBoundary(pos1) || isNearBoundary(pos2);
  }
  
  /**
   * Calculate distances from each vertex to the nearest river vertex
   * @param {Object} graph - Graph data
   * @returns {Map<number, number>} Map of vertex index to distance from nearest river
   */
  calculateRiverDistances(graph) {
    const distances = new Map();
    const visited = new Set();
    const queue = [];
    
    // Initialize queue with all river vertices at distance 0
    for (const riverVertex of this.riverVertices) {
      if (graph.circumcenters[riverVertex]) {
        distances.set(riverVertex, 0);
        queue.push({ vertex: riverVertex, distance: 0 });
        visited.add(riverVertex);
      }
    }
    
    // BFS to calculate distances
    while (queue.length > 0) {
      const { vertex, distance } = queue.shift();
      
      const connections = graph.voronoiVertexVertexMap[vertex] || [];
      for (const neighbor of connections) {
        if (!visited.has(neighbor) && graph.circumcenters[neighbor]) {
          const newDistance = distance + 1;
          if (newDistance <= this.settings.maxDistanceInfluence) {
            distances.set(neighbor, newDistance);
            queue.push({ vertex: neighbor, distance: newDistance });
            visited.add(neighbor);
          }
        }
      }
    }
    
    console.log(`TributariesGenerator: Calculated distances for ${distances.size} vertices`);
    return distances;
  }
  
  /**
   * Generate tributaries for a single main river
   * @param {Array<number>} riverPath - Main river path
   * @param {Object} weightedGraph - Graph with weighted edges
   * @param {number} riverIndex - Index of the river
   * @returns {Array<Array<number>>} Generated tributary paths
   */
  generateTributariesForRiver(riverPath, weightedGraph, riverIndex) {
    const tributaries = [];
    
    // Generate L-system string for branching pattern
    const lSystemString = this.generateLSystemString('F', this.settings.maxDepth);
    console.log(`TributariesGenerator: L-system pattern for river ${riverIndex}: ${lSystemString}`);
    
    // Find potential branching points along the river
    const branchingPoints = this.findBranchingPoints(riverPath, weightedGraph);
    console.log('--------------------------------');
    console.log(branchingPoints);
    console.log(`TributariesGenerator: Found ${branchingPoints.length} potential branching points`);
    console.log('TributariesGenerator: Branching points:', branchingPoints);
    
    // Execute L-system commands to create tributaries
    const tributaryCommands = this.parseLSystemString(lSystemString);
    console.log(`TributariesGenerator: Generated ${tributaryCommands.length} tributary commands:`, tributaryCommands);
    
    let commandIndex = 0;
    for (const branchPoint of branchingPoints) {
      if (commandIndex >= tributaryCommands.length) {
        console.log(`TributariesGenerator: No more commands (${commandIndex}/${tributaryCommands.length}), stopping`);
        break;
      }
      
      const command = tributaryCommands[commandIndex];
      console.log(`TributariesGenerator: Processing command ${commandIndex}:`, command, 'at branch point:', branchPoint);
      
      if (command.type === 'branch') {
        const tributary = this.createTributary(
          branchPoint.vertex, 
          branchPoint.direction,
          weightedGraph, 
          command.depth,
          riverIndex
        );
        
        console.log(`TributariesGenerator: Tributary creation result:`, tributary);
        
        if (tributary && tributary.length >= this.settings.minTributaryLength) {
          tributaries.push(tributary);
          console.log(`TributariesGenerator: Accepted tributary with ${tributary.length} vertices (depth ${command.depth})`);
        } else if (tributary) {
          console.log(`TributariesGenerator: Rejected tributary (length ${tributary.length} < min ${this.settings.minTributaryLength})`);
        } else {
          console.log(`TributariesGenerator: Failed to create tributary`);
        }
      }
      commandIndex++;
    }
    
    return tributaries;
  }
  
  /**
   * Generate L-system string using grammar rules
   * @param {string} axiom - Starting symbol
   * @param {number} iterations - Number of iterations
   * @returns {string} Generated L-system string
   */
  generateLSystemString(axiom, iterations) {
    let current = axiom;
    
    for (let i = 0; i < iterations; i++) {
      let next = '';
      
      for (const symbol of current) {
        const applicableRules = this.lSystemRules.filter(rule => rule.symbol === symbol);
        
        if (applicableRules.length > 0) {
          // Choose rule based on probability
          const rand = this.random();
          let cumulativeProbability = 0;
          let selectedRule = null;
          
          for (const rule of applicableRules) {
            cumulativeProbability += rule.probability;
            if (rand <= cumulativeProbability) {
              selectedRule = rule;
              break;
            }
          }
          
          next += selectedRule ? selectedRule.replacement : symbol;
        } else {
          next += symbol;
        }
      }
      
      current = next;
    }
    
    return current;
  }
  
  /**
   * Parse L-system string into executable commands
   * @param {string} lSystemString - L-system string to parse
   * @returns {Array<Object>} Array of command objects
   */
  parseLSystemString(lSystemString) {
    const commands = [];
    let depth = 0;
    
    for (const symbol of lSystemString) {
      switch (symbol) {
        case 'F':
          // Forward/extend command - not used for branching
          break;
        case '+':
          commands.push({ type: 'branch', direction: 'left', depth });
          break;
        case '-':
          commands.push({ type: 'branch', direction: 'right', depth });
          break;
        case '[':
          depth++;
          break;
        case ']':
          depth = Math.max(0, depth - 1);
          break;
      }
    }
    
    return commands;
  }
  
  /**
   * Find potential branching points along a river
   * @param {Array<number>} riverPath - River path vertices
   * @param {Object} graph - Graph data
   * @returns {Array<Object>} Branching point objects
   */
  findBranchingPoints(riverPath, graph) {
    const branchingPoints = [];
    const minBranchingSeparation = this.settings.branchingSeparation;
    
    const startSkip = Math.min(3, Math.floor(riverPath.length * 0.15));
    const endSkip = Math.min(3, Math.floor(riverPath.length * 0.15));
    
    console.log(`TributariesGenerator: Searching for branching points in river of length ${riverPath.length}`);
    console.log(`TributariesGenerator: Skipping first ${startSkip} and last ${endSkip} vertices, checking separation of ${minBranchingSeparation}`);
    
    let lastBranchingIndex = -minBranchingSeparation;
    let candidatesChecked = 0;
    let candidatesSkippedForSeparation = 0;
    let candidatesWithoutConnections = 0;
    
    for (let i = startSkip; i < riverPath.length - endSkip; i++) {
      candidatesChecked++;
      
      if (i - lastBranchingIndex < minBranchingSeparation) {
        candidatesSkippedForSeparation++;
        continue;
      }
      
      const vertex = riverPath[i];
      const connections = graph.voronoiVertexVertexMap[vertex] || [];
      const nonRiverConnections = connections.filter(conn => !this.riverVertices.has(conn));
      
      console.log(`TributariesGenerator: Vertex ${vertex} at index ${i}: ${connections.length} total connections, ${nonRiverConnections.length} non-river connections`);
      
      if (nonRiverConnections.length >= 1) { // Reduced requirement from 2 to 1
        const direction = this.determineFlowDirection(riverPath, i);
        branchingPoints.push({
          vertex,
          connections: nonRiverConnections,
          direction,
          riverIndex: i
        });
        lastBranchingIndex = i;
        console.log(`TributariesGenerator: Added branching point at vertex ${vertex} with direction ${direction}`);
      } else {
        candidatesWithoutConnections++;
      }
    }
    
    console.log(`TributariesGenerator: Branching point search complete:`);
    console.log(`  - Candidates checked: ${candidatesChecked}`);
    console.log(`  - Skipped for separation: ${candidatesSkippedForSeparation}`);
    console.log(`  - Without sufficient connections: ${candidatesWithoutConnections}`);
    console.log(`  - Branching points found: ${branchingPoints.length}`);
    
    return branchingPoints;
  }
  
  /**
   * Determine flow direction at a point in the river
   * @param {Array<number>} riverPath - River path vertices
   * @param {number} index - Index in the river path
   * @returns {string} Flow direction ('left' or 'right')
   */
  determineFlowDirection(riverPath, index) {
    // Simple determination based on position in river
    // Could be enhanced with actual geometric calculations
    return (index % 2 === 0) ? 'left' : 'right';
  }
  
  /**
   * Create a single tributary branch
   * @param {number} startVertex - Starting vertex for tributary
   * @param {string} direction - Branching direction
   * @param {Object} weightedGraph - Graph with weighted edges
   * @param {number} depth - Current branching depth
   * @param {number} riverIndex - Parent river index
   * @returns {Array<number>|null} Tributary path or null if failed
   */
  createTributary(startVertex, direction, weightedGraph, depth, riverIndex) {
    // Find a suitable endpoint for the tributary
    const endVertex = this.findTributaryEndpoint(startVertex, direction, weightedGraph, depth);
    console.log('--------------------------------');
    console.log(endVertex);
    if (!endVertex) {
      return null;
    }
    
    // Use pathfinding to create the tributary
    const tributaryPath = this.pathfinder.findPath(
      startVertex,
      endVertex,
      weightedGraph.voronoiVertexVertexMap,
      weightedGraph.voronoiEdges,
      weightedGraph.circumcenters
    );
    
    // Validate the tributary before accepting it
    if (!this.validateTributary(tributaryPath, startVertex, endVertex, weightedGraph)) {
      return null;
    }
    
    console.log(`TributariesGenerator: Created tributary from ${startVertex} to ${endVertex} (${tributaryPath.length} vertices, depth ${depth})`);
    return tributaryPath;
  }

  /**
   * Validate a tributary path to ensure it meets quality requirements
   * @param {Array<number>} tributaryPath - The generated tributary path
   * @param {number} startVertex - Starting vertex
   * @param {number} endVertex - Ending vertex
   * @param {Object} graph - Graph data
   * @returns {boolean} True if tributary is valid
   */
  validateTributary(tributaryPath, startVertex, endVertex, graph) {
    // Check minimum length
    if (tributaryPath.length < this.settings.minTributaryLength) return false;
    
    // Check that path moves away from river
    const startPos = graph.circumcenters[startVertex];
    const endPos = graph.circumcenters[endVertex];
    if (!startPos || !endPos) return false;
    
    const distance = Math.sqrt(
      Math.pow(endPos.x - startPos.x, 2) + 
      Math.pow(endPos.z - startPos.z, 2)
    );
    
    return distance >= this.settings.minTributaryDistance; // Ensure meaningful separation
  }
  
  /**
   * Find a suitable endpoint for a tributary
   * @param {number} startVertex - Starting vertex
   * @param {string} direction - Branching direction
   * @param {Object} graph - Graph data
   * @param {number} depth - Current depth
   * @returns {number|null} Endpoint vertex or null
   */
  findTributaryEndpoint(startVertex, direction, graph, depth) {
    const startPos = graph.circumcenters[startVertex];
    if (!startPos) return null;
    
    // Improved distance scaling - longer tributaries
    const minDistance = this.settings.minTributaryDistance;
    const maxDistance = Math.max(50, this.settings.maxTributaryDistance / (depth + 1));
    const candidates = [];
    
    for (let i = 0; i < graph.circumcenters.length; i++) {
      const vertex = graph.circumcenters[i];
      if (!vertex || this.riverVertices.has(i) || i === startVertex) continue;
      
      const distance = Math.sqrt(
        Math.pow(vertex.x - startPos.x, 2) + 
        Math.pow(vertex.z - startPos.z, 2)
      );
      
      // Apply distance constraints
      if (distance >= minDistance && distance <= maxDistance) {
        // Apply direction constraints
        const isLeftSide = vertex.x < startPos.x;
        const directionMatches = (direction === 'left' && isLeftSide) || 
                               (direction === 'right' && !isLeftSide);
        
        if (directionMatches) {
          candidates.push({ vertex: i, distance });
        }
      }
    }
    
    // Select from farther candidates, not closest ones
    if (candidates.length === 0) return null;
    
    candidates.sort((a, b) => b.distance - a.distance); // Sort by distance DESC
    const maxCandidates = Math.min(candidates.length, 3);
    const selectedIndex = Math.floor(this.random() * maxCandidates);
    
    return candidates[selectedIndex].vertex;
  }
  
  /**
   * Get all generated tributary paths
   * @returns {Array<Array<number>>} Array of tributary paths
   */
  getTributaryPaths() {
    return [...this.tributaryPaths];
  }
  
  /**
   * Clear all tributary data
   */
  clearTributaries() {
    this.tributaryPaths = [];
    this.riverVertices.clear();
    this.mainRiverPaths = [];
  }
  
  /**
   * Get statistics about generated tributaries
   * @returns {Object} Tributary statistics
   */
  getTributaryStats() {
    const totalTributaries = this.tributaryPaths.length;
    const totalVertices = this.tributaryPaths.reduce((sum, path) => sum + path.length, 0);
    const averageLength = totalTributaries > 0 ? totalVertices / totalTributaries : 0;
    const longestTributary = totalTributaries > 0 ? 
      Math.max(...this.tributaryPaths.map(path => path.length)) : 0;
    
    return {
      totalTributaries,
      totalVertices,
      averageLength,
      longestTributary,
      mainRivers: this.mainRiverPaths.length
    };
  }
}