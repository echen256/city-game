<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terrain Generation Dashboard</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            color: #00ff88;
            margin-bottom: 10px;
        }
        
        .controls {
            background-color: #2a2a2a;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            border: 1px solid #444;
        }
        
        .control-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #444;
        }
        
        .control-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .control-section h3 {
            color: #00ff88;
            margin-top: 0;
            margin-bottom: 15px;
        }
        
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        button {
            background-color: #00ff88;
            color: #000000;
            border: none;
            padding: 12px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #00cc66;
        }
        
        button:disabled {
            background-color: #666666;
            color: #999999;
            cursor: not-allowed;
        }
        
        .settings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .setting-item label {
            color: #cccccc;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .setting-item input, .setting-item select {
            background-color: #1a1a1a;
            border: 1px solid #666;
            color: white;
            padding: 8px;
            border-radius: 3px;
        }
        
        .status {
            background-color: #1a1a1a;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
            border: 1px solid #333;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .stat-item {
            background-color: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #00ff88;
        }
        
        .stat-label {
            font-size: 12px;
            color: #cccccc;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .canvas-container {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #444;
            text-align: center;
        }
        
        canvas {
            border: 1px solid #666;
            background-color: #0a0a0a;
            max-width: 100%;
            height: auto;
        }
        
        .log {
            background-color: #0a0a0a;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 15px;
            border: 1px solid #333;
        }
        
        .hidden {
            display: none;
        }
        
        .coast-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        
        .coast-controls select {
            background-color: #1a1a1a;
            border: 1px solid #666;
            color: white;
            padding: 8px;
            border-radius: 3px;
        }
        
        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .voronoi-cell-hover {
            position: absolute;
            border-radius: 50%;
            background-color: transparent;
            cursor: pointer;
            pointer-events: auto;
        }
        
        .voronoi-cell-hover:hover {
            background-color: rgba(255, 255, 0, 0.3);
        }
        
        .voronoi-vertex-hover {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(255, 0, 0, 0.7);
            cursor: pointer;
            pointer-events: auto;
            border: 2px solid #ff0000;
        }
        
        .voronoi-vertex-hover:hover {
            background-color: rgba(255, 0, 0, 0.9);
        }
        
        .neighbor-highlight {
            background-color: rgba(255, 0, 0, 0.5) !important;
            pointer-events: none;
        }
        
        .vertex-highlight {
            background-color: rgba(255, 255, 0, 0.8) !important;
            border-color: #ffff00 !important;
            pointer-events: none;
        }
        
        .cell-info-widget {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #2a2a2a;
            border: 1px solid #666;
            border-radius: 5px;
            padding: 15px;
            color: white;
            font-family: monospace;
            font-size: 12px;
            display: none;
            z-index: 1000;
            min-width: 200px;
        }
        
        .cell-info-widget h4 {
            margin: 0 0 10px 0;
            color: #00ff88;
        }
        
        .cell-info-line {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Terrain Generation Dashboard</h1>
            <p>Generate and visualize Voronoi-based terrain features</p>
        </div>
        
        <div class="controls">
            <!-- Voronoi Generation -->
            <div class="control-section">
                <h3>1. Voronoi Diagram</h3>
                <div class="button-group">
                    <button id="generateVoronoiBtn">Generate Voronoi Diagram</button>
                    <button id="importDataBtn">Import Data JSON</button>
                    <button id="clearAllBtn">Clear All</button>
                </div>
                <div class="settings">
                    <div class="setting-item" style="grid-column: 1 / -1;">
                        <label>Import JSON File</label>
                        <input type="file" id="jsonFileInput" accept=".json" style="display: none;">
                    </div>
                </div>
                <div class="settings">
                    <div class="setting-item">
                        <label>Number of Sites</label>
                        <input type="number" id="numSites" value="50" min="10" max="200">
                    </div>
                    <div class="setting-item">
                        <label>Distribution</label>
                        <select id="distribution">
                            <option value="poisson">Poisson Disk</option>
                            <option value="random">Random</option>
                            <option value="grid">Grid</option>
                            <option value="hexagonal">Hexagonal</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label>Poisson Radius</label>
                        <input type="number" id="poissonRadius" value="25" min="10" max="50">
                    </div>
                    <div class="setting-item">
                        <label>Seed</label>
                        <input type="number" id="seed" value="12345">
                    </div>
                </div>
            </div>
            
            <!-- Coastline Generation -->
            <div class="control-section">
                <h3>2. Coastlines</h3>
                <div class="coast-controls">
                    <select id="coastDirection">
                        <option value="N">North</option>
                        <option value="S">South</option>
                        <option value="E">East</option>
                        <option value="W">West</option>
                    </select>
                    <button id="generateCoastBtn" disabled>Generate Coastline</button>
                    <button id="clearCoastBtn" disabled>Clear Coastlines</button>
                </div>
                <div class="settings">
                    <div class="setting-item">
                        <label>Coast Budget</label>
                        <input type="number" id="coastBudget" value="50" min="10" max="500" step="10">
                    </div>
                </div>
            </div>
            
            <!-- Hills Generation -->
            <div class="control-section">
                <h3>3. Hills & Elevation</h3>
                <div class="button-group">
                    <button id="generateHillsBtn" disabled>Generate Hills</button>
                    <button id="clearHillsBtn" disabled>Clear Hills</button>
                </div>
                <div class="settings">
                    <div class="setting-item">
                        <label>Hills Budget</label>
                        <input type="number" id="hillsBudget" value="100" min="20" max="500" step="10">
                    </div>
                    <div class="setting-item">
                        <label>Number of Origins</label>
                        <input type="number" id="hillsOrigins" value="3" min="1" max="10">
                    </div>
                    <div class="setting-item">
                        <label>Gradient Enabled</label>
                        <select id="hillsGradient">
                            <option value="true">Yes</option>
                            <option value="false">No</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Water Features -->
            <div class="control-section">
                <h3>4. Water Features</h3>
                <div class="button-group">
                    <button id="generateLakesBtn" disabled>Generate Lakes</button>
                    <button id="clearLakesBtn" disabled>Clear Lakes</button>
                    <button id="generateRiversBtn" disabled>Generate Rivers</button>
                    <button id="clearRiversBtn" disabled>Clear Rivers</button>
                </div>
                <div class="settings">
                    <div class="setting-item">
                        <label>Lakes Budget</label>
                        <input type="number" id="lakesBudget" value="30" min="10" max="200" step="5">
                    </div>
                    <div class="setting-item">
                        <label>Number of Lakes</label>
                        <input type="number" id="lakesOrigins" value="2" min="1" max="5">
                    </div>
                    <div class="setting-item">
                        <label>Number of Rivers</label>
                        <input type="number" id="riversCount" value="2" min="1" max="4">
                    </div>
                </div>
            </div>

            <!-- Marshes -->
            <div class="control-section">
                <h3>5. Marshes</h3>
                <div class="button-group">
                    <button id="generateMarshesBtn" disabled>Generate Marshes</button>
                    <button id="clearMarshesBtn" disabled>Clear Marshes</button>
                </div>
                <p style="font-size: 12px; color: #999; margin-top: 10px;">
                    Marshes appear automatically in areas within 2 cells of both lakes and coastlines.
                </p>
            </div>
            
            <!-- Visualization Controls -->
            <div class="control-section">
                <h3>6. Visualization</h3>
                <div class="button-group">
                    <button id="toggleTriangulationBtn">Toggle Triangulation</button>
                    <button id="toggleVoronoiBtn">Toggle Voronoi Edges</button>
                    <button id="toggleSitesBtn">Toggle Sites</button>
                    <button id="toggleVerticesBtn">Toggle Vertices</button>
                    <button id="toggleHeightBtn">Toggle Height Gradient</button>
                    <button id="toggleLakesBtn">Toggle Lakes</button>
                    <button id="toggleMarshesBtn">Toggle Marshes</button>
                    <button id="toggleRiversBtn">Toggle Rivers</button>
                    <button id="exportImageBtn" disabled>Export Image</button>
                    <button id="exportDataBtn" disabled>Export Data JSON</button>
                </div>
            </div>
        </div>
        
        <div class="status">
            <h3>Status</h3>
            <p id="statusText">Ready to generate terrain features...</p>
            
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-value" id="sitesCount">0</div>
                    <div class="stat-label">Sites</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="cellsCount">0</div>
                    <div class="stat-label">Cells</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="trianglesCount">0</div>
                    <div class="stat-label">Triangles</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="coastalCellsCount">0</div>
                    <div class="stat-label">Coastal Cells</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="hillCellsCount">0</div>
                    <div class="stat-label">Hill Cells</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="maxHeight">0</div>
                    <div class="stat-label">Max Height</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="lakeCellsCount">0</div>
                    <div class="stat-label">Lake Cells</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="maxDepth">0</div>
                    <div class="stat-label">Max Depth</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="marshCellsCount">0</div>
                    <div class="stat-label">Marsh Cells</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="riversCount">0</div>
                    <div class="stat-label">Rivers</div>
                </div>
            </div>
            
            <div class="log" id="logOutput"></div>
        </div>
        
        <div class="canvas-container">
            <h3>Current Diagram</h3>
            <div class="canvas-wrapper">
                <canvas id="canvas" width="800" height="600"></canvas>
                <div id="cellHoverElements"></div>
                <div id="vertexHoverElements"></div>
            </div>
        </div>
        
        <div id="cellInfoWidget" class="cell-info-widget">
            <h4>Cell Information</h4>
            <div class="cell-info-line">ID: <span id="cellId">-</span></div>
            <div class="cell-info-line">Position: <span id="cellPosition">-</span></div>
            <div class="cell-info-line">Neighbors: <span id="cellNeighbors">-</span></div>
            <div class="cell-info-line">Type: <span id="infoType">Cell</span></div>
            <div class="cell-info-line" id="vertexInfo" style="display: none;">Connected Cells: <span id="connectedCells">-</span></div>
        </div>
    </div>

    <script type="module">
        import { VoronoiGenerator } from './voronoi/VoronoiGenerator.js';
        import { VoronoiImageExporter } from './voronoi/VoronoiImageExporter.js';
        import { CoastlineGenerator } from './coastlines/CoastlineGenerator.js';
        import { HillsGenerator } from './hills/HillsGenerator.js';
        import { LakesGenerator } from './lakes/LakesGenerator.js';
        import { MarshGenerator } from './marshes/MarshGenerator.js';
        import { RiversGenerator } from './rivers/RiversGenerator.js';

        // State
        let voronoiGenerator = null;
        let imageExporter = null;
        let coastlineGenerator = null;
        let hillsGenerator = null;
        let lakesGenerator = null;
        let marshGenerator = null;
        let riversGenerator = null;
        let showTriangulation = true;
        let showVoronoi = true;
        let showSites = true;
        let showVertices = true;
        let showHeightGradient = true;
        let showLakes = true;
        let showMarshes = true;
        let showRivers = true;
        let selectedCellId = null; // Track which cell is selected
        let highlightedNeighbors = new Set(); // Track highlighted neighbor cells
        let selectedVertexIndex = null; // Track which vertex is selected
        let highlightedVertices = new Set(); // Track highlighted connected vertices

        // Mock terrain data
        const mockTerrainData = {
            features: new Map(),
            featureCounter: 0,
            createFeature: function(type) {
                const id = `${type}_${++this.featureCounter}`;
                const feature = {
                    id, type,
                    centroid: { x: 0, z: 0 },
                    bezierCurves: [],
                    pointDistributions: [],
                    affectedTiles: [],
                    metadata: {},
                    setCentroid: function(x, z) { this.centroid = { x, z }; return this; },
                    addBezierCurve: function(curve) { this.bezierCurves.push(curve); return this; },
                    addPointDistribution: function(points) { this.pointDistributions.push(points); return this; },
                    addAffectedTile: function(x, z) { this.affectedTiles.push({ x, z }); return this; },
                    setMetadata: function(key, value) { this.metadata[key] = value; return this; },
                    getMetadata: function(key) { return this.metadata[key]; }
                };
                this.features.set(id, feature);
                return feature;
            },
            getFeaturesByType: function(type) {
                return Array.from(this.features.values()).filter(f => f.type === type);
            }
        };

        // Utility functions
        function log(message) {
            const logOutput = document.getElementById('logOutput');
            const timestamp = new Date().toLocaleTimeString();
            logOutput.innerHTML += `[${timestamp}] ${message}\n`;
            logOutput.scrollTop = logOutput.scrollHeight;
            console.log(message);
        }

        function updateStatus(message) {
            document.getElementById('statusText').textContent = message;
        }

        function updateStats() {
            if (!voronoiGenerator) {
                document.getElementById('sitesCount').textContent = '0';
                document.getElementById('cellsCount').textContent = '0';
                document.getElementById('trianglesCount').textContent = '0';
                document.getElementById('coastalCellsCount').textContent = '0';
                document.getElementById('hillCellsCount').textContent = '0';
                document.getElementById('maxHeight').textContent = '0';
                document.getElementById('lakeCellsCount').textContent = '0';
                document.getElementById('maxDepth').textContent = '0';
                document.getElementById('marshCellsCount').textContent = '0';
                document.getElementById('riversCount').textContent = '0';
                return;
            }

            const sites = voronoiGenerator.sites ? voronoiGenerator.sites.length : 0;
            const cells = voronoiGenerator.cells ? voronoiGenerator.cells.size : 0;
            const triangles = voronoiGenerator.getTriangulation()?.triangles?.length || 0;
            const coastalCells = coastlineGenerator ? coastlineGenerator.getCoastalCells().length : 0;
            const hillCells = hillsGenerator ? hillsGenerator.getHillCells().length : 0;
            const heightStats = hillsGenerator ? hillsGenerator.getHeightStats() : null;
            const maxHeight = heightStats ? Math.round(heightStats.maxHeight) : 0;
            const lakeCells = lakesGenerator ? lakesGenerator.getLakeCells().length : 0;
            const depthStats = lakesGenerator ? lakesGenerator.getDepthStats() : null;
            const maxDepth = depthStats ? Math.round(depthStats.maxDepth) : 0;
            const marshCells = marshGenerator ? marshGenerator.getMarshCells().length : 0;
            const riversCount = riversGenerator ? riversGenerator.getRiverPaths().length : 0;

            document.getElementById('sitesCount').textContent = sites;
            document.getElementById('cellsCount').textContent = cells;
            document.getElementById('trianglesCount').textContent = triangles;
            document.getElementById('coastalCellsCount').textContent = coastalCells;
            document.getElementById('hillCellsCount').textContent = hillCells;
            document.getElementById('maxHeight').textContent = maxHeight;
            document.getElementById('lakeCellsCount').textContent = lakeCells;
            document.getElementById('maxDepth').textContent = maxDepth;
            document.getElementById('marshCellsCount').textContent = marshCells;
            document.getElementById('riversCount').textContent = riversCount;
        }

        function getSettings() {
            return {
                gridSize: 600,
                voronoi: {
                    enabled: true,
                    numSites: parseInt(document.getElementById('numSites').value),
                    distribution: document.getElementById('distribution').value,
                    poissonRadius: parseInt(document.getElementById('poissonRadius').value),
                    seed: parseInt(document.getElementById('seed').value)
                }
            };
        }

        function enableDependentButtons(enable) {
            const buttons = ['generateCoastBtn', 'clearCoastBtn', 'generateHillsBtn', 'clearHillsBtn', 'generateLakesBtn', 'clearLakesBtn', 'generateRiversBtn', 'clearRiversBtn', 'generateMarshesBtn', 'clearMarshesBtn', 'exportImageBtn', 'exportDataBtn'];
            buttons.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.disabled = !enable;
                    console.log(`${enable ? 'Enabled' : 'Disabled'} button: ${id}`);
                } else {
                    console.error(`Button not found: ${id}`);
                }
            });
        }

        function createCellHoverElements() {
            const hoverContainer = document.getElementById('cellHoverElements');
            const canvas = document.getElementById('canvas');
            
            // Clear existing hover elements
            hoverContainer.innerHTML = '';
            
            if (!voronoiGenerator || !voronoiGenerator.cells) {
                return;
            }
            
            const scaleX = canvas.width / voronoiGenerator.settings.gridSize;
            const scaleZ = canvas.height / voronoiGenerator.settings.gridSize;
            const hoverRadius = 5; // 10px radius as requested
            
            voronoiGenerator.cells.forEach((cell, cellId) => {
                if (!cell.site) return;
                
                const hoverElement = document.createElement('div');
                hoverElement.className = 'voronoi-cell-hover';
                hoverElement.style.left = `${(cell.site.x * scaleX) - hoverRadius}px`;
                hoverElement.style.top = `${((cell.site.z || cell.site.y || 0) * scaleZ) - hoverRadius}px`;
                hoverElement.style.width = `${hoverRadius * 2}px`;
                hoverElement.style.height = `${hoverRadius * 2}px`;
                
                // Add data attribute for identification
                hoverElement.dataset.cellId = cellId;
                
                // Add hover event listeners
                hoverElement.addEventListener('mouseenter', () => {
                    showCellInfo(cellId, cell);
                });
                
                hoverElement.addEventListener('mouseleave', () => {
                    hideCellInfo();
                });
                
                // Add click event listener for neighbor highlighting
                hoverElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (selectedCellId === cellId) {
                        // If clicking the same cell, clear highlights
                        clearNeighborHighlights();
                    } else {
                        // Highlight neighbors of clicked cell
                        highlightNeighbors(cellId, cell);
                    }
                });
                
                hoverContainer.appendChild(hoverElement);
            });
            
            // Create vertex hover elements
            const triangulationData = voronoiGenerator.getTriangulation();
            createVertexHoverElements(triangulationData);
        }

        function createVertexHoverElements(triangulationData) {
            const vertexContainer = document.getElementById('vertexHoverElements');
            const canvas = document.getElementById('canvas');
            
            // Clear existing vertex elements
            vertexContainer.innerHTML = '';
            
            if (!voronoiGenerator || !triangulationData) {
                return;
            }
            
            if (!triangulationData.delaunayCircumcenters) {
                return;
            }
            
            const scaleX = canvas.width / voronoiGenerator.settings.gridSize;
            const scaleZ = canvas.height / voronoiGenerator.settings.gridSize;
            const vertexRadius = 1; // 5px radius for vertices (10px diameter)
            
            triangulationData.delaunayCircumcenters.forEach((circumcenter, vertexIndex) => {
                if (!circumcenter) return;
                
                const vertexElement = document.createElement('div');
                vertexElement.className = 'voronoi-vertex-hover';
                vertexElement.style.left = `${(circumcenter.x * scaleX) - vertexRadius}px`;
                vertexElement.style.top = `${(circumcenter.z * scaleZ) - vertexRadius}px`;
                vertexElement.style.width = `${vertexRadius * 2}px`;
                vertexElement.style.height = `${vertexRadius * 2}px`;
                
                // Add data attribute for identification
                vertexElement.dataset.vertexIndex = vertexIndex;
                
                // Add hover event listeners
                vertexElement.addEventListener('mouseenter', () => {
                    showVertexInfo(vertexIndex, circumcenter);
                });
                
                vertexElement.addEventListener('mouseleave', () => {
                    hideCellInfo();
                });
                
                // Add click event listener for connected vertex highlighting
                vertexElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (selectedVertexIndex === vertexIndex) {
                        // If clicking the same vertex, clear highlights
                        clearVertexHighlights();
                    } else {
                        // Highlight connected vertices
                        highlightConnectedVertices(vertexIndex, circumcenter);
                    }
                });
                
                vertexContainer.appendChild(vertexElement);
            });
        }

        function showCellInfo(cellId, cell) {
            const widget = document.getElementById('cellInfoWidget');
            const cellIdSpan = document.getElementById('cellId');
            const cellPositionSpan = document.getElementById('cellPosition');
            const cellNeighborsSpan = document.getElementById('cellNeighbors');
            const infoTypeSpan = document.getElementById('infoType');
            const vertexInfoDiv = document.getElementById('vertexInfo');
            
            // Update widget content
            cellIdSpan.textContent = cellId;
            
            const x = cell.site.x.toFixed(1);
            const y = (cell.site.z || cell.site.y || 0).toFixed(1);
            cellPositionSpan.textContent = `(${x}, ${y})`;
            
            // Get neighbors array
            const neighbors = cell.neighbors ? Array.from(cell.neighbors).sort((a, b) => a - b) : [];
            cellNeighborsSpan.textContent = `[${neighbors.join(', ')}]`;
            
            // Set type to Cell
            infoTypeSpan.textContent = 'Cell';
            vertexInfoDiv.style.display = 'none';
            
            // Show widget
            widget.style.display = 'block';
        }

        function showVertexInfo(vertexIndex, circumcenter) {
            const widget = document.getElementById('cellInfoWidget');
            const cellIdSpan = document.getElementById('cellId');
            const cellPositionSpan = document.getElementById('cellPosition');
            const cellNeighborsSpan = document.getElementById('cellNeighbors');
            const infoTypeSpan = document.getElementById('infoType');
            const vertexInfoDiv = document.getElementById('vertexInfo');
            const connectedCellsSpan = document.getElementById('connectedCells');
            
            // Update widget content for vertex
            cellIdSpan.textContent = `Vertex ${vertexIndex}`;
            
            const x = circumcenter.x.toFixed(1);
            const y = circumcenter.z.toFixed(1);
            cellPositionSpan.textContent = `(${x}, ${y})`;
            
            // Find connected cells (cells that share this vertex)
            const triangulationData = voronoiGenerator.getTriangulation();
            const connectedCells = findCellsConnectedToVertex(vertexIndex, triangulationData);
            cellNeighborsSpan.textContent = `[${connectedCells.join(', ')}]`;
            
            // Set type to Vertex and show connected cells info
            infoTypeSpan.textContent = 'Vertex';
            connectedCellsSpan.textContent = `[${connectedCells.join(', ')}]`;
            vertexInfoDiv.style.display = 'block';
            
            // Show widget
            widget.style.display = 'block';
        }

        function findCellsConnectedToVertex(vertexIndex, triangulationData) {
            if (!voronoiGenerator || !triangulationData) {
                return [];
            }
            
            if (!triangulationData.triangles) {
                return [];
            }
            
            const connectedCells = new Set();
            
            // Find triangles that contain this vertex index
            triangulationData.triangles.forEach((triangle, triangleIndex) => {
                if (triangle && triangleIndex === vertexIndex) {
                    // This triangle corresponds to our vertex
                    if (triangle.indices) {
                        triangle.indices.forEach(cellIndex => {
                            connectedCells.add(cellIndex);
                        });
                    }
                }
            });
            
            return Array.from(connectedCells).sort((a, b) => a - b);
        }

        function hideCellInfo() {
            const widget = document.getElementById('cellInfoWidget');
            widget.style.display = 'none';
        }

        function clearNeighborHighlights() {
            // Remove highlight class from all previously highlighted elements
            const hoverContainer = document.getElementById('cellHoverElements');
            const highlightedElements = hoverContainer.querySelectorAll('.neighbor-highlight');
            highlightedElements.forEach(element => {
                element.classList.remove('neighbor-highlight');
            });
            highlightedNeighbors.clear();
            selectedCellId = null;
        }

        function clearVertexHighlights() {
            // Remove highlight class from all previously highlighted vertex elements
            const vertexContainer = document.getElementById('vertexHoverElements');
            const highlightedElements = vertexContainer.querySelectorAll('.vertex-highlight');
            highlightedElements.forEach(element => {
                element.classList.remove('vertex-highlight');
            });
            highlightedVertices.clear();
            selectedVertexIndex = null;
        }

        function highlightNeighbors(cellId, cell) {
            // Clear previous highlights
            clearNeighborHighlights();
            clearVertexHighlights();
            
            // Set new selection
            selectedCellId = cellId;
            
            if (!cell.neighbors || cell.neighbors.length === 0) {
                return;
            }
            
            // Get hover container for finding neighbor elements
            const hoverContainer = document.getElementById('cellHoverElements');
            const hoverElements = hoverContainer.children;
            
            // Highlight each neighbor
            cell.neighbors.forEach(neighborId => {
                highlightedNeighbors.add(neighborId);
                
                // Find the corresponding hover element
                // Elements are created in the same order as cells.forEach()
                for (let i = 0; i < hoverElements.length; i++) {
                    const element = hoverElements[i];
                    if (element.dataset.cellId == neighborId) {
                        element.classList.add('neighbor-highlight');
                        break;
                    }
                }
            });
        }

        function highlightConnectedVertices(vertexIndex, circumcenter) {
            // Clear previous highlights
            clearNeighborHighlights();
            clearVertexHighlights();
            
            // Set new selection
            selectedVertexIndex = vertexIndex;
             
            const connectedVertices = voronoiGenerator.findConnectedVertices(vertexIndex);
            
            // Get vertex container for finding vertex elements
            const vertexContainer = document.getElementById('vertexHoverElements');
            const vertexElements = vertexContainer.children;
            
            // Highlight each connected vertex
            connectedVertices.forEach(connectedVertexIndex => {
                highlightedVertices.add(connectedVertexIndex);
                
                // Find the corresponding vertex element
                for (let i = 0; i < vertexElements.length; i++) {
                    const element = vertexElements[i];
                    if (element.dataset.vertexIndex == connectedVertexIndex) {
                        element.classList.add('vertex-highlight');
                        break;
                    }
                }
            });
        }

        function drawDiagram() {
            if (!voronoiGenerator || !imageExporter) return;

            try {
                // Store reference for image exporter
                imageExporter.voronoiGenerator = voronoiGenerator;
                
                // Set coastline generator reference if available
                if (coastlineGenerator) {
                    imageExporter.setCoastlineGenerator(coastlineGenerator);
                }
                
                // Set hills generator reference if available
                if (hillsGenerator) {
                    imageExporter.setHillsGenerator(hillsGenerator);
                }
                
                // Set lakes generator reference if available
                if (lakesGenerator) {
                    imageExporter.setLakesGenerator(lakesGenerator);
                }

                if (riversGenerator) {
                    imageExporter.setRiversGenerator(riversGenerator);
                }
                
                // Set marsh generator reference if available
                if (marshGenerator) {
                    imageExporter.setMarshGenerator(marshGenerator);
                }
                
                // Get triangulation data once
                const triangulationData = voronoiGenerator.getTriangulation();
                
                const canvas = imageExporter.generateDiagramImage(
                    voronoiGenerator.getCells(),
                    voronoiGenerator.sites,
                    triangulationData,
                    {
                        width: 800,
                        height: 600,
                        backgroundColor: '#0a0a0a',
                        cellFillColors: ['#1a3a1a', '#2a4a2a', '#3a5a3a', '#4a6a4a'],
                        cellStrokeColor: '#cccccc',
                        siteColor: '#ffff00',
                        triangulationColor: '#ffffff',
                        voronoiColor: '#00ff88',
                        coastalColor: '#0088ff',
                        showSites: showSites,
                        showCellBorders: true,
                        showTriangulation: showTriangulation,
                        showVoronoiEdges: showVoronoi,
                        showVertices: showVertices,
                        showCoastalCells: true,
                        showHeightGradient: showHeightGradient,
                        showLakes: showLakes,
                        showMarshes: showMarshes,
                        showRivers: showRivers,
                        lineWidth: 1,
                        siteRadius: 3
                    }
                );

                // Copy to display canvas
                const displayCanvas = document.getElementById('canvas');
                const ctx = displayCanvas.getContext('2d');
                ctx.clearRect(0, 0, displayCanvas.width, displayCanvas.height);
                ctx.drawImage(canvas, 0, 0);

                // Create hover elements for cell interaction
                createCellHoverElements();

            } catch (error) {
                log(`Error drawing diagram: ${error.message}`);
                console.error(error);
            }
        }

        // Event handlers
        document.getElementById('generateVoronoiBtn').addEventListener('click', function() {
            try {
                updateStatus('Generating Voronoi diagram...');
                log('Starting Voronoi generation');

                const settings = getSettings();
                voronoiGenerator = new VoronoiGenerator(mockTerrainData, settings);
                imageExporter = new VoronoiImageExporter(voronoiGenerator, settings);
                coastlineGenerator = new CoastlineGenerator(voronoiGenerator, settings);
                hillsGenerator = new HillsGenerator(voronoiGenerator, settings);
                lakesGenerator = new LakesGenerator(voronoiGenerator, settings);
                marshGenerator = new MarshGenerator(voronoiGenerator, settings);
                riversGenerator = new RiversGenerator(voronoiGenerator, settings);

                voronoiGenerator.generateVoronoi();
                
                updateStats();
                drawDiagram();
                enableDependentButtons(true);
                
                updateStatus('Voronoi diagram generated successfully');
                log(`Generated ${voronoiGenerator.sites.length} sites and ${voronoiGenerator.cells.size} cells`);

            } catch (error) {
                updateStatus(`Error: ${error.message}`);
                log(`Error generating Voronoi: ${error.message}`);
                console.error(error);
            }
        });

        document.getElementById('importDataBtn').addEventListener('click', function() {
            document.getElementById('jsonFileInput').click();
        });

        document.getElementById('jsonFileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.name.endsWith('.json')) {
                updateStatus('Error: Please select a JSON file');
                log('Error: Invalid file type. Please select a JSON file.');
                return;
            }

            updateStatus('Loading JSON file...');
            log(`Loading file: ${file.name} (${Math.round(file.size / 1024)} KB)`);

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    // Validate the imported data structure
                    if (!importedData.metadata || !importedData.points || !importedData.triangles) {
                        throw new Error('Invalid JSON structure. Missing required fields.');
                    }

                    if (importedData.metadata.version !== '1.0') {
                        log(`Warning: Version mismatch. Expected 1.0, got ${importedData.metadata.version}`);
                    }

                    updateStatus('Reconstructing Voronoi diagram from imported data...');
                    log('Validating imported data structure...');

                    // Create new generators with imported settings
                    const settings = importedData.metadata.settings || getSettings();
                    voronoiGenerator = new VoronoiGenerator(mockTerrainData, settings);
                    imageExporter = new VoronoiImageExporter(voronoiGenerator, settings);
                    coastlineGenerator = new CoastlineGenerator(voronoiGenerator, settings);
                    hillsGenerator = new HillsGenerator(voronoiGenerator, settings);
                    lakesGenerator = new LakesGenerator(voronoiGenerator, settings);
                    marshGenerator = new MarshGenerator(voronoiGenerator, settings);
                    riversGenerator = new RiversGenerator(voronoiGenerator, settings);

                    // Reconstruct DelaunatorWrapper from imported data
                    reconstructDelaunatorWrapper(importedData);

                    // Reconstruct VoronoiGenerator cells from imported data
                    reconstructVoronoiCells(importedData);

                    updateStats();
                    drawDiagram();
                    enableDependentButtons(true);

                    updateStatus(`Imported data successfully: ${importedData.points.length} points, ${importedData.triangles.length} triangles`);
                    log(`Successfully imported: ${importedData.points.length} points, ${importedData.triangles.length} triangles, ${importedData.edges.length} edges, ${importedData.voronoiCells.length} cells`);
                    log(`Original export: ${importedData.metadata.exportTimestamp}`);

                    // Clear the file input
                    event.target.value = '';

                } catch (error) {
                    updateStatus(`Error loading JSON: ${error.message}`);
                    log(`Error loading JSON file: ${error.message}`);
                    console.error('JSON Import Error:', error);
                    
                    // Clear the file input on error
                    event.target.value = '';
                }
            };

            reader.onerror = function() {
                updateStatus('Error reading file');
                log('Error: Failed to read the selected file');
                event.target.value = '';
            };

            reader.readAsText(file);
        });

        function reconstructDelaunatorWrapper(importedData) {
            log('Reconstructing DelaunatorWrapper...');
            
            // Reconstruct points array
            const points = importedData.points.map(pointData => ({
                x: pointData.x,
                z: pointData.z,
                isBoundary: pointData.isBoundary
            }));

            // Create new DelaunatorWrapper instance
            voronoiGenerator.delaunatorWrapper = new (voronoiGenerator.delaunatorWrapper?.constructor || class {
                constructor(points) {
                    this.points = points;
                    this.triangles = [];
                    this.edges = [];
                    this.voronoiCells = new Map();
                    this.delaunayCircumcenters = [];
                    this.voronoiAdjacentCells = {};
                    this.validCellIndices = null;
                    this.indexMapping = null;
                }
            })(points);

            const wrapper = voronoiGenerator.delaunatorWrapper;

            // Reconstruct triangles
            wrapper.triangles = importedData.triangles.map(triangleData => ({
                a: triangleData.vertices.a,
                b: triangleData.vertices.b,
                c: triangleData.vertices.c,
                indices: triangleData.indices,
                getCircumcenter: function() {
                    return triangleData.circumcenter;
                },
                getArea: function() {
                    return triangleData.area;
                }
            }));

            // Reconstruct edges
            wrapper.edges = importedData.edges.map(edgeData => ({
                a: edgeData.pointA,
                b: edgeData.pointB,
                id: edgeData.id,
                length: function() {
                    return edgeData.length;
                }
            }));

            // Reconstruct voronoi cells
            wrapper.voronoiCells.clear();
            importedData.voronoiCells.forEach(cellData => {
                wrapper.voronoiCells.set(cellData.index, {
                    site: cellData.site,
                    siteIndex: cellData.site.index,
                    vertices: cellData.vertices,
                    neighbors: new Set(cellData.neighbors)
                });
            });

            // Reconstruct circumcenters
            wrapper.delaunayCircumcenters = importedData.delaunayCircumcenters.map(centerData => 
                centerData.x !== null ? { x: centerData.x, z: centerData.z } : null
            );

            // Reconstruct adjacent cells
            wrapper.voronoiAdjacentCells = {};
            Object.entries(importedData.voronoiAdjacentCells).forEach(([key, value]) => {
                wrapper.voronoiAdjacentCells[key] = new Set(value);
            });

            // Reconstruct index mapping
            if (importedData.indexMapping.validCellIndices) {
                wrapper.validCellIndices = new Set(importedData.indexMapping.validCellIndices);
            }
            if (importedData.indexMapping.indexMapping) {
                wrapper.indexMapping = new Map(Object.entries(importedData.indexMapping.indexMapping).map(([k, v]) => [parseInt(k), v]));
            }

            // Reconstruct raw Delaunay data if available
            if (importedData.delaunayRawData) {
                wrapper.delaunay = {
                    triangles: new Uint32Array(importedData.delaunayRawData.triangles),
                    halfedges: new Int32Array(importedData.delaunayRawData.halfedges),
                    hull: new Uint32Array(importedData.delaunayRawData.hull)
                };
            }

            log('DelaunatorWrapper reconstruction complete');
        }

        function reconstructVoronoiCells(importedData) {
            log('Reconstructing VoronoiGenerator cells...');
            
            // Clear existing cells
            voronoiGenerator.cells.clear();
            
            // Reconstruct sites array (filter out boundary points)
            voronoiGenerator.sites = importedData.points
                .filter(pointData => !pointData.isBoundary)
                .map(pointData => ({
                    x: pointData.x,
                    z: pointData.z
                }));

            // Reconstruct VoronoiCell instances
            importedData.voronoiCells.forEach(cellData => {
                // Skip boundary cells if they exist
                const correspondingPoint = importedData.points[cellData.site.index];
                if (correspondingPoint && correspondingPoint.isBoundary) {
                    return;
                }

                const cell = new (voronoiGenerator.cells.get(0)?.constructor || class {
                    constructor(site, id) {
                        this.site = site;
                        this.id = id;
                        this.vertices = [];
                        this.neighbors = [];
                        this.area = 0;
                        this.perimeter = 0;
                        this.affectedTiles = [];
                        this.metadata = {};
                    }
                    addVertex(vertex) { this.vertices.push(vertex); return this; }
                    addNeighbor(id) { if (!this.neighbors.includes(id)) this.neighbors.push(id); return this; }
                    calculateArea() { return 0; }
                    calculatePerimeter() { return 0; }
                    setMetadata(key, value) { this.metadata[key] = value; return this; }
                    getMetadata(key) { return this.metadata[key]; }
                })(cellData.site, cellData.index);

                // Reconstruct vertices
                cellData.vertices.forEach(vertex => {
                    cell.addVertex(vertex);
                });

                // Reconstruct neighbors
                cellData.neighbors.forEach(neighborId => {
                    cell.addNeighbor(neighborId);
                });

                voronoiGenerator.cells.set(cellData.index, cell);
            });

            log('VoronoiGenerator cells reconstruction complete');
        }

        document.getElementById('generateCoastBtn').addEventListener('click', function() {
            if (!coastlineGenerator) return;

            try {
                const direction = document.getElementById('coastDirection').value;
                const budget = parseInt(document.getElementById('coastBudget').value);
                updateStatus(`Generating ${direction} coastline with budget ${budget}...`);
                
                const coastalCells = coastlineGenerator.generateCoastline(direction, budget);
                
                updateStats();
                drawDiagram();
                
                updateStatus(`Generated coastline with ${coastalCells.length} coastal cells (budget: ${budget})`);
                log(`Generated ${direction} coastline: ${coastalCells.length} cells with budget ${budget}`);

            } catch (error) {
                updateStatus(`Error: ${error.message}`);
                log(`Error generating coastline: ${error.message}`);
                console.error(error);
            }
        });

        document.getElementById('clearCoastBtn').addEventListener('click', function() {
            if (!coastlineGenerator) return;

            coastlineGenerator.clearCoastline();
            updateStats();
            drawDiagram();
            updateStatus('Coastlines cleared');
            log('Cleared all coastlines');
        });

        document.getElementById('generateHillsBtn').addEventListener('click', function() {
            if (!hillsGenerator) return;

            try {
                const budget = parseInt(document.getElementById('hillsBudget').value);
                const numOrigins = parseInt(document.getElementById('hillsOrigins').value);
                const gradientEnabled = document.getElementById('hillsGradient').value === 'true';
                
                updateStatus(`Generating hills with budget ${budget}, ${numOrigins} origins...`);
                
                const hillCells = hillsGenerator.generateHills(budget, numOrigins, gradientEnabled);
                const heightStats = hillsGenerator.getHeightStats();
                
                updateStats();
                drawDiagram();
                
                updateStatus(`Generated ${hillCells.length} hill cells (max height: ${Math.round(heightStats.maxHeight)})`);
                log(`Generated hills: ${hillCells.length} cells, ${numOrigins} origins, gradient: ${gradientEnabled}`);
                if (heightStats.gradientEdges.length > 0) {
                    log(`Gradient edges: ${heightStats.gradientEdges.join(', ')}`);
                }

            } catch (error) {
                updateStatus(`Error: ${error.message}`);
                log(`Error generating hills: ${error.message}`);
                console.error(error);
            }
        });

        document.getElementById('clearHillsBtn').addEventListener('click', function() {
            if (!hillsGenerator) return;

            hillsGenerator.clearHills();
            updateStats();
            drawDiagram();
            updateStatus('Hills cleared');
            log('Cleared all hills');
        });

        document.getElementById('generateLakesBtn').addEventListener('click', function() {
            if (!lakesGenerator) return;

            try {
                const budget = parseInt(document.getElementById('lakesBudget').value);
                const numOrigins = parseInt(document.getElementById('lakesOrigins').value);
                
                // Set references to other generators to avoid overlaps
                lakesGenerator.setCoastlineGenerator(coastlineGenerator);
                lakesGenerator.setHillsGenerator(hillsGenerator);
                
                updateStatus(`Generating lakes with budget ${budget}, ${numOrigins} origins...`);
                
                const lakeCells = lakesGenerator.generateLakes(budget, numOrigins);
                const depthStats = lakesGenerator.getDepthStats();
                
                updateStats();
                drawDiagram();
                
                updateStatus(`Generated ${lakeCells.length} lake cells (max depth: ${Math.round(depthStats.maxDepth)})`);
                log(`Generated lakes: ${lakeCells.length} cells, ${numOrigins} origins`);
                log(`Depth range: ${Math.round(depthStats.minDepth)} - ${Math.round(depthStats.maxDepth)}`);

            } catch (error) {
                updateStatus(`Error: ${error.message}`);
                log(`Error generating lakes: ${error.message}`);
                console.error(error);
            }
        });

        document.getElementById('clearLakesBtn').addEventListener('click', function() {
            if (!lakesGenerator) return;

            lakesGenerator.clearLakes();
            updateStats();
            drawDiagram();
            updateStatus('Lakes cleared');
            log('Cleared all lakes');
        });

        document.getElementById('generateRiversBtn').addEventListener('click', function() {
            if (!riversGenerator) return;

            try {
                const numRivers = parseInt(document.getElementById('riversCount').value);
                
                // Set references to other generators for pathfinding
                riversGenerator.setCoastlineGenerator(coastlineGenerator);
                riversGenerator.setLakesGenerator(lakesGenerator);
                riversGenerator.setMarshGenerator(marshGenerator);
                riversGenerator.setHillsGenerator(hillsGenerator);
                
                updateStatus(`Generating ${numRivers} rivers...`);
                
                const riverPaths = riversGenerator.generateRivers(numRivers);
                const riverStats = riversGenerator.getRiverStats();
                
                updateStats();
                drawDiagram();
                
                updateStatus(`Generated ${riverPaths.length} rivers (avg length: ${Math.round(riverStats.averageRiverLength)})`);
                log(`Generated rivers: ${riverPaths.length} paths, ${riverStats.totalRiverCells} total cells`);
                if (riverStats.longestRiver > 0) {
                    log(`Longest river: ${riverStats.longestRiver} cells`);
                }

            } catch (error) {
                updateStatus(`Error: ${error.message}`);
                log(`Error generating rivers: ${error.message}`);
                console.error(error);
            }
        });

        document.getElementById('clearRiversBtn').addEventListener('click', function() {
            if (!riversGenerator) return;

            riversGenerator.clearRivers();
            updateStats();
            drawDiagram();
            updateStatus('Rivers cleared');
            log('Cleared all rivers');
        });

        document.getElementById('generateMarshesBtn').addEventListener('click', function() {
            if (!marshGenerator) return;

            try {
                // Set references to other generators for proximity detection
                marshGenerator.setCoastlineGenerator(coastlineGenerator);
                marshGenerator.setLakesGenerator(lakesGenerator);
                
                updateStatus('Generating marshes...');
                
                const marshCells = marshGenerator.generateMarshes();
                const marshStats = marshGenerator.getMarshStats();
                
                updateStats();
                drawDiagram();
                
                updateStatus(`Generated ${marshCells.length} marsh cells`);
                log(`Generated marshes: ${marshCells.length} cells between lakes and coasts`);

            } catch (error) {
                updateStatus(`Error: ${error.message}`);
                log(`Error generating marshes: ${error.message}`);
                console.error(error);
            }
        });

        document.getElementById('clearMarshesBtn').addEventListener('click', function() {
            if (!marshGenerator) return;

            marshGenerator.clearMarshes();
            updateStats();
            drawDiagram();
            updateStatus('Marshes cleared');
            log('Cleared all marshes');
        });

        document.getElementById('clearAllBtn').addEventListener('click', function() {
            voronoiGenerator = null;
            imageExporter = null;
            coastlineGenerator = null;
            hillsGenerator = null;
            lakesGenerator = null;
            marshGenerator = null;
            riversGenerator = null;
            
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Clear hover elements
            const hoverContainer = document.getElementById('cellHoverElements');
            hoverContainer.innerHTML = '';
            
            // Clear vertex hover elements
            const vertexContainer = document.getElementById('vertexHoverElements');
            vertexContainer.innerHTML = '';
            
            // Hide info widget
            hideCellInfo();
            
            // Reset selection state
            selectedCellId = null;
            selectedVertexIndex = null;
            highlightedNeighbors.clear();
            highlightedVertices.clear();
            
            updateStats();
            enableDependentButtons(false);
            updateStatus('All data cleared');
            log('Cleared all data');
        });

        document.getElementById('toggleTriangulationBtn').addEventListener('click', function() {
            showTriangulation = !showTriangulation;
            drawDiagram();
            log(`Triangulation ${showTriangulation ? 'enabled' : 'disabled'}`);
        });

        document.getElementById('toggleVoronoiBtn').addEventListener('click', function() {
            showVoronoi = !showVoronoi;
            drawDiagram();
            log(`Voronoi edges ${showVoronoi ? 'enabled' : 'disabled'}`);
        });

        document.getElementById('toggleSitesBtn').addEventListener('click', function() {
            showSites = !showSites;
            drawDiagram();
            log(`Sites ${showSites ? 'enabled' : 'disabled'}`);
        });

        document.getElementById('toggleVerticesBtn').addEventListener('click', function() {
            showVertices = !showVertices;
            drawDiagram();
            log(`Vertices ${showVertices ? 'enabled' : 'disabled'}`);
        });

        document.getElementById('toggleHeightBtn').addEventListener('click', function() {
            showHeightGradient = !showHeightGradient;
            drawDiagram();
            log(`Height gradient ${showHeightGradient ? 'enabled' : 'disabled'}`);
        });

        document.getElementById('toggleLakesBtn').addEventListener('click', function() {
            showLakes = !showLakes;
            drawDiagram();
            log(`Lakes ${showLakes ? 'enabled' : 'disabled'}`);
        });

        document.getElementById('toggleMarshesBtn').addEventListener('click', function() {
            showMarshes = !showMarshes;
            drawDiagram();
            log(`Marshes ${showMarshes ? 'enabled' : 'disabled'}`);
        });

        document.getElementById('toggleRiversBtn').addEventListener('click', function() {
            showRivers = !showRivers;
            drawDiagram();
            log(`Rivers ${showRivers ? 'enabled' : 'disabled'}`);
        });

        document.getElementById('exportImageBtn').addEventListener('click', function() {
            if (!imageExporter) return;
            
            try {
                const dataURL = imageExporter.exportAsDataURL();
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = `terrain_${Date.now()}.png`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                log('Image exported successfully');
            } catch (error) {
                log(`Error exporting image: ${error.message}`);
            }
        });

        document.getElementById('exportDataBtn').addEventListener('click', function() {
            if (!voronoiGenerator || !voronoiGenerator.delaunatorWrapper) {
                log('Error: No Voronoi data available to export');
                return;
            }
            
            try {
                updateStatus('Exporting DelaunatorWrapper data...');
                
                const delaunatorWrapper = voronoiGenerator.delaunatorWrapper;
                
                // Prepare export data object
                const exportData = {
                    metadata: {
                        exportTimestamp: new Date().toISOString(),
                        version: '1.0',
                        description: 'Voronoi Delaunator data export',
                        settings: voronoiGenerator.settings
                    },
                    points: delaunatorWrapper.points.map((point, index) => ({
                        index: index,
                        x: point.x,
                        z: point.z || point.y || 0,
                        isBoundary: point.isBoundary || false
                    })),
                    triangles: delaunatorWrapper.triangles.map((triangle, index) => ({
                        index: index,
                        indices: triangle.indices,
                        vertices: {
                            a: { x: triangle.a.x, z: triangle.a.z || triangle.a.y || 0 },
                            b: { x: triangle.b.x, z: triangle.b.z || triangle.b.y || 0 },
                            c: { x: triangle.c.x, z: triangle.c.z || triangle.c.y || 0 }
                        },
                        circumcenter: triangle.getCircumcenter ? triangle.getCircumcenter() : null,
                        area: triangle.getArea ? triangle.getArea() : null
                    })),
                    edges: delaunatorWrapper.edges.map((edge, index) => ({
                        index: index,
                        id: edge.id,
                        pointA: { x: edge.a.x, z: edge.a.z || edge.a.y || 0 },
                        pointB: { x: edge.b.x, z: edge.b.z || edge.b.y || 0 },
                        length: edge.length ? edge.length() : null
                    })),
                    voronoiCells: Array.from(delaunatorWrapper.voronoiCells.entries()).map(([index, cell]) => ({
                        index: index,
                        site: {
                            x: cell.site.x,
                            z: cell.site.z || cell.site.y || 0,
                            index: cell.siteIndex
                        },
                        vertices: cell.vertices.map(vertex => ({
                            x: vertex.x,
                            z: vertex.z,
                            triangleIndex: vertex.triangleIndex
                        })),
                        neighbors: Array.from(cell.neighbors || [])
                    })),
                    delaunayCircumcenters: delaunatorWrapper.delaunayCircumcenters ? 
                        delaunatorWrapper.delaunayCircumcenters.map((center, index) => ({
                            index: index,
                            x: center ? center.x : null,
                            z: center ? center.z : null
                        })) : [],
                    voronoiAdjacentCells: delaunatorWrapper.voronoiAdjacentCells ? 
                        Object.fromEntries(
                            Object.entries(delaunatorWrapper.voronoiAdjacentCells).map(([key, value]) => [
                                key, 
                                Array.from(value || [])
                            ])
                        ) : {},
                    indexMapping: {
                        validCellIndices: delaunatorWrapper.validCellIndices ? 
                            Array.from(delaunatorWrapper.validCellIndices) : null,
                        indexMapping: delaunatorWrapper.indexMapping ? 
                            Object.fromEntries(delaunatorWrapper.indexMapping) : null
                    },
                    delaunayRawData: delaunatorWrapper.delaunay ? {
                        triangles: Array.from(delaunatorWrapper.delaunay.triangles),
                        halfedges: Array.from(delaunatorWrapper.delaunay.halfedges),
                        hull: Array.from(delaunatorWrapper.delaunay.hull)
                    } : null
                };
                
                // Convert to JSON string
                const jsonString = JSON.stringify(exportData, null, 2);
                
                // Create and download file
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `voronoi_data_${Date.now()}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                updateStatus(`Data exported successfully (${Math.round(jsonString.length / 1024)} KB)`);
                log(`Exported DelaunatorWrapper data: ${exportData.points.length} points, ${exportData.triangles.length} triangles, ${exportData.edges.length} edges, ${exportData.voronoiCells.length} cells`);
                
            } catch (error) {
                updateStatus(`Error: ${error.message}`);
                log(`Error exporting data: ${error.message}`);
                console.error(error);
            }
        });

        // Add document click listener to clear highlights when clicking outside
        document.addEventListener('click', (e) => {
            // Only clear if not clicking on a hover element
            if (!e.target.classList.contains('voronoi-cell-hover') && 
                !e.target.classList.contains('voronoi-vertex-hover')) {
                clearNeighborHighlights();
                clearVertexHighlights();
            }
        });

        // Initialize
        log('Dashboard initialized');
        updateStatus('Ready to generate terrain features');
    </script>
</body>
</html>